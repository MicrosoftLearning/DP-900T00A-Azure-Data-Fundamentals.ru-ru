---
ms.openlocfilehash: 4f70d9e1d8895757244ec8464f178ff3068a36bd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052065"
---
# <a name="rc"></a>rc

Загрузчик конфигурации без необходимости настройки для ленивых людей.

## <a name="usage"></a>Использование

Единственным вариантом является передача rc имени приложения и конфигурации по умолчанию.

```javascript
var conf = require('rc')(appname, {
  //defaults go here.
  port: 2468,

  //defaults which are objects will be merged, not replaced
  views: {
    engine: 'jade'
  }
});
```

`rc` возвращает параметры конфигурации, объединенные с заданными значениями по умолчанию.
Если передать стандартный объект по умолчанию, он будет изменен:

```javascript
var conf = {};
require('rc')(appname, conf);
```

Если `rc` обнаружил файлы конфигурации для приложения, возвращаемый объект конфигурации будет содержать массив `configs`, содержащий их пути:

```javascript
var appCfg = require('rc')(appname, conf);
appCfg.configs[0] // /etc/appnamerc
appCfg.configs[1] // /home/dominictarr/.config/appname
appCfg.config // same as appCfg.configs[appCfg.configs.length - 1]
```

## <a name="standards"></a>Стандарты

Учитывая имя приложения (`appname`), rc будет выполнять поиск во всех очевидных местах для настройки.

  * аргументы командной строки, проанализированные minimist _(например `--foo baz`, а также вложенные: `--foo.bar=baz`)_
  * переменные среды с префиксом `${appname}_`.
    * или используйте "\_\_" для указания вложенных свойств <br/> _(например, `appname_foo__bar__baz` => `foo.bar.baz`)_
  * если вы передали параметр `--config file`, то из этого файла
  * местный `.${appname}rc` или первый найденный при поиске в `./ ../ ../../ ../../../` и т. д.
  * `$HOME/.${appname}rc`
  * `$HOME/.${appname}/config`
  * `$HOME/.config/${appname}`
  * `$HOME/.config/${appname}/config`
  * `/etc/${appname}rc`
  * `/etc/${appname}/config`
  * объект по умолчанию, переданный вами.

Все найденные источники конфигурации будут объединены в один объект, чтобы источники, **указанные ранее** в этом списке, переопределили те, которые указаны позднее.


## <a name="configuration-file-formats"></a>Форматы файлов конфигурации

Файлы конфигурации (например, `.appnamerc`) могут быть в формате [JSON](http://json.org/example) или [ini](http://en.wikipedia.org/wiki/INI_file). **Не** следует использовать расширение файла (`.json` или `.ini`). Примеры конфигураций, приведенные ниже, являются эквивалентными:


#### <a name="formatted-as-ini"></a>В формате `ini`

```
; You can include comments in `ini` format if you want.

dependsOn=0.10.0


; `rc` has built-in support for ini sections, see?

[commands]
  www     = ./commands/www
  console = ./commands/repl


; You can even do nested sections

[generators.options]
  engine  = ejs

[generators.modules]
  new     = generate-new
  engine  = generate-backend

```

#### <a name="formatted-as-json"></a>В формате `json`

```javascript
{
  // You can even comment your JSON, if you want
  "dependsOn": "0.10.0",
  "commands": {
    "www": "./commands/www",
    "console": "./commands/repl"
  },
  "generators": {
    "options": {
      "engine": "ejs"
    },
    "modules": {
      "new": "generate-new",
      "backend": "generate-backend"
    }
  }
}
```

Примечания удаляются из конфигурации JSON с помощью [strip-json-comments](https://github.com/sindresorhus/strip-json-comments).

> Так как переменные ini и env не имеют стандарта для типов, приложение должно быть подготовлено для строковых значений.

Чтобы гарантировать, что строковые представления логических и числовых значений всегда преобразуются в надлежащие типы (особенно полезно, если вы планируете выполнять строгие сравнения `===`), попробуйте использовать такой модуль, как [parse-strings-in-object](https://github.com/anselanza/parse-strings-in-object), для переноса объекта конфигурации, возвращаемого из rc.


## <a name="simple-example-demonstrating-precedence"></a>Простой пример, демонстрирующий приоритетность
Предположим, у вас есть подобное приложение (обратите внимание на жестко закодированные значения по умолчанию, передаваемые в rc):
```
const conf = require('rc')('myapp', {
    port: 12345,
    mode: 'test'
});

console.log(JSON.stringify(conf, null, 2));
```
Кроме того, у вас есть файл `config.json`со следующим содержимым:
```
{
  "port": 9000,
  "foo": "from config json",
  "something": "else"
}
```
И файл `.myapprc` в той же папке со следующим содержимым:
```
{
  "port": "3001",
  "foo": "bar"
}
```
Ниже приведены ожидаемые выходные данные различных команд:

`node .`
```
{
  "port": "3001",
  "mode": "test",
  "foo": "bar",
  "_": [],
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc"
  ],
  "config": "/Users/stephen/repos/conftest/.myapprc"
}
```
*Значение по умолчанию `mode` из жестко закодированного объекта сохраняется, но порт переопределяется файлом `.myapprc` (автоматически найден с учетом сопоставления имени приложения) и добавляется `foo`.*


`node . --foo baz`
```
{
  "port": "3001",
  "mode": "test",
  "foo": "baz",
  "_": [],
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc"
  ],
  "config": "/Users/stephen/repos/conftest/.myapprc"
}
```
*Тот же результат, что и выше, но `foo` переопределен, так как аргументы командной строки имеют приоритет над файлом `.myapprc`.*

`node . --foo barbar --config config.json`
```
{
  "port": 9000,
  "mode": "test",
  "foo": "barbar",
  "something": "else",
  "_": [],
  "config": "config.json",
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc",
    "config.json"
  ]
}
```
*Теперь `port` поступает из указанного файла `config.json` (переопределение значения из `.myapprc`), а значение `foo` переопределено командной строкой, несмотря на то, то он также указан в файле `config.json`.*
 


## <a name="advanced-usage"></a>Расширенные возможности использования

#### <a name="pass-in-your-own-argv"></a>Передайте свой собственный `argv`

Вы можете передать свой собственный аргумент `argv` в качестве третьего аргумента для `rc`.  Это происходит в том случае, если вы хотите [использовать собственное средство синтаксического анализа в командной строке](https://github.com/dominictarr/rc/pull/12).

```javascript
require('rc')(appname, defaults, customArgvParser);
```

## <a name="pass-in-your-own-parser"></a>Передача собственного средства синтаксического анализа

Если у вас есть особое требование относительно использования нестандартного средства синтаксического анализа, это можно сделать, передав средство синтаксического анализа в качестве четвертого аргумента.
(оставьте третье значение нулевым, чтобы получить средство синтаксического анализа аргументов по умолчанию)

```javascript
require('rc')(appname, defaults, null, parser);
```

Его также можно использовать для принудительного применения более строгого формата, например строгого допустимого формата JSON.

## <a name="note-on-performance"></a>Примечание о производительности

`rc` выполняется `fs.statSync`, поэтому следует убедиться, что вы не используете его в пути к коду горячего уровня доступа (например, обработчик запроса) 


## <a name="license"></a>Лицензия

Многопользовательская лицензия в рамках лицензии BSD с двумя предложениями, лицензии MIT или лицензии Apache, версия 2.0
