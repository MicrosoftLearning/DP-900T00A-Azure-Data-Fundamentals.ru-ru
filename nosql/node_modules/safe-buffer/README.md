---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053054"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![загрузки][downloads-image]][downloads-url] [![javascript, руководство по стилю][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>Безопасный класс Buffer в Node.js

**Используйте новые методы Buffer (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) во всех версиях Node.js.**

**При возможности используется встроенная реализация.**

## <a name="install"></a>Установка

```
npm install safe-buffer
```

## <a name="usage"></a>usage

Этот пакет предлагает безопасную замену для класса `Buffer` в Node.js.

Это прямая замена для `Buffer`. Пакет можно использовать сразу, добавив одну строку `require` в начало модуля node.js:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Метод класса: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Выделяет новый экземпляр `Buffer` с помощью массива (`array`) октетов.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

Если `array` имеет тип, отличный от `Array`, вызывается ошибка `TypeError`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Метод класса: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} Свойство `.buffer` массива `TypedArray` или `new ArrayBuffer()`
* `byteOffset` {Number} По умолчанию: `0`
* `length` {Number} По умолчанию: `arrayBuffer.length - byteOffset`

При передаче ссылки на свойство `.buffer` экземпляра `TypedArray` только что созданный буфер `Buffer` будет использовать ту же выделенную память, что и TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Необязательные аргументы `byteOffset` и `length` задают диапазон памяти внутри `arrayBuffer`, к которому получит доступ экземпляр `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

Если `arrayBuffer` имеет тип, отличный от `ArrayBuffer`, вызывается ошибка `TypeError`.

### <a name="class-method-bufferfrombuffer"></a>Метод класса: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Копирует переданные данные `buffer` в новый экземпляр `Buffer`.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

Если `buffer` имеет тип, отличный от `Buffer`, вызывается ошибка `TypeError`.

### <a name="class-method-bufferfromstr-encoding"></a>Метод класса: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} Кодируемая строка.
* `encoding` {String} Используемая кодировка, по умолчанию: `'utf8'`

Создает новый объект `Buffer`, содержащий заданную строку JavaScript `str`. Если указан параметр `encoding`, он определяет кодировку символов.
Если он не указан, `encoding` имеет значение по умолчанию `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

Если `str` имеет тип, отличный от string, вызывается ошибка `TypeError`.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Метод класса: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} По умолчанию: `undefined`
* `encoding` {String} По умолчанию: `utf8`

Выделяет новый буфер `Buffer` с размером `size` Б. Если `fill` имеет значение `undefined`, `Buffer` *заполняется нулями*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Значение `size` должно быть меньше или равно значению `require('buffer').kMaxLength` (в 64-разрядных архитектурах`kMaxLength` равно `(2^31)-1`). В противном случае возникает исключение [`RangeError`][]. Если значение `size` меньше или равно 0, создается экземпляр Buffer нулевой длины.

Если указан параметр `fill`, выделенный экземпляр `Buffer` инициализируется с помощью метода `buf.fill(fill)`. Дополнительные сведения см. в разделе [`buf.fill()`][].

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Если указаны оба параметра, `fill` и `encoding`, выделенный экземпляр `Buffer` инициализируется с помощью метода `buf.fill(fill, encoding)`. Пример:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

Вызов метода `Buffer.alloc(size)` может выполняться значительно медленнее, чем `Buffer.allocUnsafe(size)`, однако он гарантирует, что содержимое созданного экземпляра `Buffer` *не содержит конфиденциальные данные*.

Если `size` имеет тип, отличный от number, вызывается ошибка `TypeError`.

### <a name="class-method-bufferallocunsafesize"></a>Метод класса: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Выделяет новый объект `Buffer` размером `size` Б *с элементами, не равными нулю*.  Значение `size` должно быть меньше или равно значению `require('buffer').kMaxLength` (в 64-разрядных архитектурах`kMaxLength` равно `(2^31)-1`). В противном случае возникает исключение [`RangeError`][]. Если значение `size` меньше или равно 0, создается экземпляр Buffer нулевой длины.

Базовая память для экземпляров `Buffer`, созданных таким образом, *не инициализируется*. Содержимое созданного экземпляра `Buffer` неизвестно и *может содержать конфиденциальные данные*. Чтобы инициализировать такие экземпляры `Buffer` нулями, используйте метод [`buf.fill(0)`][].

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Если `size` имеет тип, отличный от number, вызывается ошибка `TypeError`.

Обратите внимание, что модуль `Buffer` предварительно выделяет внутренний экземпляр `Buffer` размером `Buffer.poolSize`, который используется в качестве пула для быстрого выделения новых экземпляров `Buffer`, созданных с помощью метода `Buffer.allocUnsafe(size)` (и нерекомендуемого конструктора `new Buffer(size)`), только если значение `size` меньше или равно `Buffer.poolSize >> 1` (нижний предел `Buffer.poolSize`, деленный на два). Значение `Buffer.poolSize` по умолчанию равно `8192`, но его можно изменить.

Использование такого предварительно выделенного внутреннего пула памяти является ключевым различием между методами `Buffer.alloc(size, fill)` и `Buffer.allocUnsafe(size).fill(fill)`. В частности, `Buffer.alloc(size, fill)` *никогда* не использует внутренний пул Buffer, а `Buffer.allocUnsafe(size).fill(fill)` *будет* использовать внутренний пул Buffer, если значение `size` меньше или равно половине `Buffer.poolSize`. Разница довольно незначительная, но она может иметь значение, если приложению требуется дополнительная производительность, которую обеспечивает метод `Buffer.allocUnsafe(size)`.

### <a name="class-method-bufferallocunsafeslowsize"></a>Метод класса: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Выделяет новый объект `Buffer` размером `size` Б, который *не заполнен нулями* и не находится в пуле.  Значение `size` должно быть меньше или равно значению `require('buffer').kMaxLength` (в 64-разрядных архитектурах`kMaxLength` равно `(2^31)-1`). В противном случае возникает исключение [`RangeError`][]. Если значение `size` меньше или равно 0, создается экземпляр Buffer нулевой длины.

Базовая память для экземпляров `Buffer`, созданных таким образом, *не инициализируется*. Содержимое созданного экземпляра `Buffer` неизвестно и *может содержать конфиденциальные данные*. Чтобы инициализировать такие экземпляры `Buffer` нулями, используйте метод [`buf.fill(0)`][].

При использовании метода `Buffer.allocUnsafe()` для выделения новых экземпляров `Buffer` объекты размером менее 4 КБ по умолчанию берутся из одного предварительно выделенного экземпляра `Buffer`. Это позволяет приложениям избежать затрат на сборку мусора при создании множества отдельных выделенных объектов Buffer. Такой подход повышает производительность и эффективность использования памяти, так как устраняет необходимость отслеживать и очищать большое количество объектов `Persistent`.

Однако если разработчику необходимо получить небольшой фрагмент памяти из пула на неопределенное время, может потребоваться создать экземпляр Buffer не из пула с помощью метода `Buffer.allocUnsafeSlow()`, а затем скопировать нужные биты.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

Использовать метод `Buffer.allocUnsafeSlow()` следует только в крайнем случае, *если* разработчик заметит неоправданное удержание памяти в своих приложениях.

Если `size` имеет тип, отличный от number, вызывается ошибка `TypeError`.

### <a name="all-the-rest"></a>Остальное

Оставшаяся часть `Buffer` такая же, как и в node.js.
[См. документацию](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Связанные ссылки

- [Проблема в Node.js: небезопасный метод Buffer(number)](https://github.com/nodejs/node/issues/4660)
- [Предложение по улучшению Node.js: плавный отказ от использования Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer()](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Почему класс `Buffer` небезопасен?

В настоящее время конструктор `Buffer` в node.js перегружается, чтобы обрабатывать аргументы разных типов, таких как `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array` и т. д.), `ArrayBuffer`, а также `Number`.

Этот метод отличается в первую очередь удобством: в него можно передать любой тип, и он попытается сделать то, что необходимо.

Благодаря широким возможностям конструктора Buffer, часто можно видеть следующий код:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Но что произойдет, если вызвать метод `toHex` с аргументом `Number`?***

### <a name="remote-memory-disclosure"></a>Удаленное раскрытие памяти

Если злоумышленник заставит вашу программу вызвать конструктор `Buffer` с аргументом `Number`, то он сможет выделить неинициализированную память из процесса node.js.
Это может привести к раскрытию закрытых ключей TLS, пользовательских данных или паролей базы данных.

При передаче аргумента `Number` в конструктор `Buffer` он возвращает блок **НЕИНИЦИАЛИЗИРОВАННОЙ** памяти указанного размера `size`. При создании экземпляра `Buffer` этим способом **НЕОБХОДИМО** перезаписать его содержимое перед возвратом пользователю.

Из [документации по node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - `size` Number
>
> Базовая память для экземпляров `Buffer`, созданных таким образом, не инициализируется.
> **Содержимое созданного экземпляра `Buffer` неизвестно и может содержать конфиденциальные данные**. Чтобы инициализировать Buffer нулями, используйте метод `buf.fill(0)`.

(Полужирный шрифт автора.)

Когда программист намеревается создать неинициализированный экземпляр `Buffer`, часто можно видеть следующий код:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>А это может быть проблемой в реальном коде?

Да. На удивление часто разработчики забывают проверять тип переменных в языках с динамической типизацией, таких как JavaScript.

Обычно при использовании неправильного типа в программе возникает сбой с необработанным исключением. Однако если не проверить тип аргументов в конструкторе `Buffer`, последствия будут более катастрофическими.

Ниже приведен пример уязвимой службы, которая принимает полезные данные JSON и преобразует их в шестнадцатеричный формат:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

В этом примере HTTP-клиенту нужно просто отправить:

```json
{
  "str": 1000
}
```

и он получит обратно 1000 байт неинициализированной памяти с сервера.

Это очень серьезная ошибка. По степени серьезности это напоминает [ошибку Heartbleed](http://heartbleed.com/), которая позволяла атакующим удаленно получать доступ к памяти процесса OpenSSL.


### <a name="which-real-world-packages-were-vulnerable"></a>Какие реальные пакеты уязвимы?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Матиас Буус](https://github.com/mafintosh) и я ([Феросс Абухадиджа](http://feross.org/)) обнаружили эту проблему в одном из наших собственных пакетов, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). Эта ошибка позволяет любому пользователю в Интернете отправить ряд сообщений какому-либо пользователю `bittorrent-dht` и получить от него за раз 20 Б неинициализированной памяти из процесса node.js.

Вы можете загрузить [исправление](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) этой ошибки. Мы выпустили новую исправленную версию, [раскрыли информацию об ошибке в Node Security Project](https://nodesecurity.io/advisories/68) и отметили все уязвимые версии в npm, так что теперь пользователи получают предложение обновиться до более новой версии.

#### [`ws`](https://www.npmjs.com/package/ws)

После этого мы задумались, а есть ли другие уязвимые пакеты. Довольно быстро та же проблема была обнаружена в [`ws`](https://www.npmjs.com/package/ws), наиболее популярной реализации WebSocket в node.js.

Если в ней некоторые методы вызывались с параметрами `Number`, а не `String` или `Buffer`, как ожидалось, то удаленному одноранговому узлу раскрывалась неинициализированная память сервера.

Уязвимыми были следующие методы:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Вот пример уязвимого сервера сокетов с поддержкой echo-функциональности:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

Если на сервере вызвать `socket.send(number)`, память сервера будет раскрыта.

В [новом выпуске](https://github.com/websockets/ws/releases/tag/1.0.1) эта ошибка исправлена и приводится подробное объяснение. Спасибо [Арно Каземьеру](https://github.com/3rd-Eden) за быстрое исправление. Здесь [опубликовано сообщение в Node Security Project](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Как решать эту проблему?

Важно, чтобы node.js обеспечивал быстрое получение памяти, в противном случае приложения с высокими требованиями к производительности станут работать гораздо медленнее.

Однако программистам нужно *эффективнее сигнализировать о своих намерениях*. **Когда требуется неинициализированная память, ее нужно запрашивать явным образом.**

Функции, предусматривающие работу с конфиденциальными данными, нельзя упаковывать в удобные универсальные методы, которые свободно принимают различные типы аргументов. Такие методы поощряют передачу переменных без строгой проверки типов.

#### <a name="a-new-api-bufferallocunsafenumber"></a>Новый метод: `Buffer.allocUnsafe(number)`

Возможность создавать буферы с неинициализированной памятью необходимо реализовать в другом методе. Мы предлагаем `Buffer.allocUnsafe(number)`. Таким образом, эта функция не входит в состав метода, в который часто передаются пользовательские входные данные разных типов.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Как исправить ядро node.js?

Мы отправили [предложение об изменении ядра node.js](https://github.com/nodejs/node/pull/4514) (реализовано в версии `semver-major`), которое защищает в одной ситуации:

```js
var str = 16
new Buffer(str, 'utf8')
```

В данном случае программист предполагает, что первый аргумент имеет строковый тип, так как в качестве второго аргумента передается кодировка. В настоящее время node.js выделяет неинициализированную память при использовании метода `new Buffer(number, encoding)`, однако, возможно, программист предполагал другое поведение.

Но это лишь частичное решение, так как если программист вызывает метод `new Buffer(variable)` (без параметра `encoding`), узнать его намерение невозможно. Если иногда `variable` является числом, то иногда возвращается неинициализированная память.

### <a name="whats-the-real-long-term-fix"></a>Каким должно быть действующее долгосрочное решение?

Мы могли бы отменить и удалить метод `new Buffer(number)` и использовать `Buffer.allocUnsafe(number)`, когда требуется неинициализированная память. Однако это нарушит работу огромного количества пакетов.

~~Мы считаем, что оптимальным решением будет:~~

~~1. Сделать так, чтобы метод `new Buffer(number)` возвращал безопасную память, заполненную нулями.~~

~~2. Разработать новый метод для создания неинициализированных экземпляров Buffer. Мы предлагаем: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Update

Теперь мы поддерживаем добавление трех новых методов:

- `Buffer.from(value)` — преобразование из любого типа в Buffer;
- `Buffer.alloc(size)` — создание буфера, заполненного нулями;
- `Buffer.allocUnsafe(size)` — создание неинициализированного буфера с заданным размером.

Это решает основную проблему, которая была в `ws` и `bittorrent-dht` и позволяла передавать в `Buffer(variable)` числовой аргумент.

Таким образом, существующий код продолжает работать, и влияние на экосистему npm будет минимальным. Со временем разработчики npm могут перенести переписать код с высокими требованиями к производительности, заменив в нем метод `new Buffer(number)` на `Buffer.allocUnsafe(number)`.


### <a name="conclusion"></a>Заключение

Мы считаем, что текущая реализация класса `Buffer` содержит серьезную ошибку. Она приводит к появлению небезопасного программного обеспечения, так как включает функции, связанные с высоким риском, в удобный для разработчиков метод.

И это не теоретические рассуждения — мы обнаружили эту проблему в некоторых из самых популярных пакетов npm.

К счастью, есть простое исправление, которое можно применить уже сегодня. Используйте `safe-buffer` вместо `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

В конечном счете мы надеемся, что ядро node.js можно будет перевести на это новое безопасное поведение. Мы считаем, что соответствующее влияние на экосистему будет минимальным, так как это не критическое изменение.
Хорошо поддерживаемые, популярные пакеты можно будет быстро перевести на использование `Buffer.alloc`, а старые небезопасные пакеты получат защиту от этого вектора атаки.


## <a name="links"></a>ссылки

- [Предложение для Node.js: создание исключения в Buffer при передаче длины и кодировки одновременно](https://github.com/nodejs/node/pull/4514)
- [Сообщение в Node Security Project о `ws`](https://nodesecurity.io/advisories/67)
- [Сообщение в Node Security Project о `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>Благодарности

Исходные проблемы в `bittorrent-dht` ([сообщение](https://nodesecurity.io/advisories/68)) и `ws` ([сообщение](https://nodesecurity.io/advisories/67)) были обнаружены [Матиасом Буусом](https://github.com/mafintosh) и [Фероссом Абухадиджа](http://feross.org/).

Спасибо [Адаму Болдуину](https://github.com/evilpacket) за помощь в раскрытии этих ошибок и за его работу над проектом [Node Security Project](https://nodesecurity.io/).

Спасибо [Джону Хизею](https://github.com/jhiesey) за редактуру этого файла README и проверку кода.


## <a name="license"></a>license

MIT. (C) [Феросс Абухадиджа](http://feross.org)
