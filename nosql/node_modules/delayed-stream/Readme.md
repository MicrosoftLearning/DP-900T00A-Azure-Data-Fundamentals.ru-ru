---
ms.openlocfilehash: 21db9b7ec97b7028a031a18867aab00575b09850
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053101"
---
# <a name="delayed-stream"></a>delayed-stream

Буферизует события из потока до тех пор, пока вы не будете готовы к их обработке.

## <a name="installation"></a>Установка

``` bash
npm install delayed-stream
```

## <a name="usage"></a>Использование

В следующем примере показано, как написать эхо-сервер HTTP, который задерживает ответ на 1000 мс.

``` javascript
var DelayedStream = require('delayed-stream');
var http = require('http');

http.createServer(function(req, res) {
  var delayed = DelayedStream.create(req);

  setTimeout(function() {
    res.writeHead(200);
    delayed.pipe(res);
  }, 1000);
});
```

Если вы не используете`Stream#pipe`, можно также вручную освобождать буферные события путем вызова `delayedStream.resume()`:

``` javascript
var delayed = DelayedStream.create(req);

setTimeout(function() {
  // Emit all buffered events and resume underlaying source
  delayed.resume();
}, 1000);
```

## <a name="implementation"></a>Реализация

Чтобы правильно использовать этот метапоток, ознакомьтесь с некоторыми сведениями о реализации.

### <a name="event-buffering--proxying"></a>Буферизация событий / проксирование

Все события потока `source` перехватываются путем перезаписи метода `source.emit`. Пока узел не реализует универсальный прослушиватель событий, это единственный способ.

Однако delayed-stream по-прежнему выдает все события, которые захватывает в `source`, независимо от того, был ли высвобожден отложенный поток или еще нет.

После создания delayed-stream захватывает все события `source` и сохраняет их во внутреннем буфере событий. После вызова `delayedStream.release()` все буферные события создаются в `delayedStream`, а буфер событий очищается. После этого отложенный поток просто выступает в качестве прокси-сервера для базового источника.

### <a name="error-handling"></a>Обработка ошибок

События ошибок в `source` буферизуются и проксируются так же, как и любые другие события.
Тем не менее, `delayedStream.create` подключает прослушиватель `'error'` к `source`. Таким образом, необходимо обрабатывать ошибки только в объекте `delayedStream`, а не в двух местах.

### <a name="buffer-limits"></a>Ограничения буферизации

Отложенный поток предоставляет свойство `maxDataSize`, которое можно использовать для ограничения объема данных, для которых осуществляется буферизация. Чтобы защитить вас от плохих потоков `source`, которые не реагируют на `source.pause()`, эта функция включена по умолчанию.

## <a name="api"></a>API

### <a name="delayedstreamcreatesource-options"></a>DelayedStream.create(source, [options])

Возвращает новый объект `delayedStream`. Доступные параметры:

* `pauseStream`
* `maxDataSize`

Описание этих свойств представлено ниже.

### <a name="delayedstreamsource"></a>delayedStream.source

Поток `source`, управляемый этим объектом. Это полезно, если вы передаете `delayedStream` и по-прежнему хотите получить доступ к свойствам объекта `source`.

### <a name="delayedstreampausestream--true"></a>delayedStream.pauseStream = true

Следует ли приостановить базовый `source` при вызове `DelayedStream.create()`. Изменение этого свойства впоследствии не дает результатов.

### <a name="delayedstreammaxdatasize--1024--1024"></a>delayedStream.maxDataSize = 1024 * 1024

Объем данных для буферизации перед выдачей `error`.

Если базовый источник генерирует объекты `Buffer`, `maxDataSize` ссылается на байты.

Если базовый источник генерирует строки JavaScript, размер ссылается на символы.

Если вы знаете, что делаете, можно задать для этого свойства значение `Infinity`, чтобы отключить эту функцию. Это свойство можно также изменить во время выполнения.

### <a name="delayedstreamdatasize--0"></a>delayedStream.dataSize = 0

Объем данных, буферизованных на данный момент.

### <a name="delayedstreamreadable"></a>delayedStream.readable

Метод получения ECMA5, возвращающий значение `source.readable`.

### <a name="delayedstreamresume"></a>delayedStream.resume()

Если `delayedStream` до сих пор не выпустили, вызывается `delayedStream.release()`

В любом случае вызывается `source.resume()`.

### <a name="delayedstreampause"></a>delayedStream.pause()

Вызывает `source.pause()`.

### <a name="delayedstreampipedest"></a>delayedStream.pipe(dest)

Вызывает `delayedStream.resume()`, а затем проксирует аргументы в `source.pipe`.

### <a name="delayedstreamrelease"></a>delayedStream.release()

Выдает и очищает все события, буферизованные на данный момент. Не возобновляет базовый источник, используйте вместо него `delayedStream.resume()`.

## <a name="license"></a>Лицензия

delayed-stream лицензируется по лицензии MIT.
