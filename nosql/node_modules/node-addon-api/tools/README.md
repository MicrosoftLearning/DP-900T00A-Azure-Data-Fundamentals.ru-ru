---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052159"
---
# <a name="tools"></a>Инструменты

## <a name="clang-format"></a>clang-format

Средство clang-format предназначено для сравнения измененных строк кода с заданными ссылками Git.

## <a name="migration-script"></a>Скрипт миграции

Средство миграции сокращает объем повторяющихся операций в процессе миграции. Однако скрипт не преобразует все за вас. Обычно требуются незначительные исправления и серьезные переделки.

### <a name="how-to-use"></a>Использование

Чтобы запустить скрипт преобразования, сначала убедитесь, что в каталоге `node_modules` находится последняя версия `node-addon-api`.
```
npm install node-addon-api
```

Затем запустите скрипт, передав в него каталог проекта.
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

По завершении выполните повторную компиляцию и устраните ошибки, которые были пропущены скриптом.


### <a name="quick-fixes"></a>Быстрые исправления
Ниже приведен список ошибок, которые легко исправить.
  1. Измените возвращаемое значение метода на void, если он не возвращает значение в JavaScript.
  2. Вместо `->` используйте `.` для доступа к атрибуту или вызова функции-члена в Napi::Object.
  3. `Napi::New(env, value);` в `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>Серьезные переделки
Реализация `Napi::ObjectWrap` значительно отличается от реализации в NAN. `Napi::ObjectWrap` принимает указатель на упакованный объект и создает ссылку на упакованный объект внутри конструктора ObjectWrap. `Napi::ObjectWrap` также связывает методы экземпляра упакованного объекта с модулем JavaScript, а не со статическими методами, как в NAN.

Поэтому если в модуле используется Nan::ObjectWrap, потребуется выполнить следующие действия.

  1. Преобразуйте функцию [ClassName]::New в функцию конструктора, которая принимает объект `Napi::CallbackInfo`. Объявите ее как
```
[ClassName](const Napi::CallbackInfo& info);
```
и определите как
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
Таким образом, конструктор `Napi::ObjectWrap` будет вызываться после создания экземпляра объекта, и `Napi::ObjectWrap` сможет использовать указатель `this` для создания ссылки на упакованный объект.

  2. Перенесите исходный код конструктора в новый конструктор. Удалите исходный конструктор.
  3. В функции инициализации класса свяжите собственные методы следующим образом.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. В функции, в которой необходимо распаковывать объект ObjectWrap в NAN, например: `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`, используйте указатель `this` в качестве неупакованного объекта, так как каждый экземпляр ObjectWrap связан с уникальным экземпляром объекта.


Если после выполнения этих инструкций у вас по-прежнему возникают проблемы, сообщите нам об этом и мы попытаемся найти решение.
