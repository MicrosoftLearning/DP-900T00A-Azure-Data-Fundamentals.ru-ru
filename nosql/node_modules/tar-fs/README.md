---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051969"
---
# <a name="tar-fs"></a>tar-fs

привязки файловой системы для [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![Статус сборки](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>Использование

Tar-fs позволяет упаковывать каталоги в tarballs и извлекать tarballs в каталоги.

Это не gunzip для вас, так что если вы хотите извлечь `.tar.gz`, вместе с этим вам потребуется использовать что-то вроде [gunzip, и может быть](https://github.com/mafintosh/gunzip-maybe) в дополнение к этому.

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

Чтобы игнорировать различные файлы при упаковке или извлечении, добавьте функцию ignore в параметры. `ignore` также является псевдонимом для `filter`. Кроме того, вы получите `header`, если вы используете ignore при извлечении.
Таким образом можно также выполнять фильтрацию по метаданным.

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

Вы также можете указать, какие записи следует упаковывать с помощью параметра `entries`.

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

Если вы хотите изменить заголовки при упаковке или извлечении, добавьте функцию сопоставления в параметры

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

Аналогичным образом можно использовать `mapStream`, если требуется изменить потоки входных и выходных файлов.

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Задайте `options.fmode` и `options.dmode`, чтобы убедиться, что извлеченные файлы и каталоги используют соответствующие режимы

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

Рекомендуется использовать `dmode` и `fmode` при упаковке или распаковке tarballs между *nix/windows, чтобы убедиться, что все распакованные файлы и каталоги доступны для чтения.

Кроме того, можно задать `options.readable` и (или) `options.writable`, чтобы задать dmode и fmode для чтения или записи.

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Задайте для `options.strict` значение `false`, если вы хотите игнорировать ошибки из-за неподдерживаемых типов записей (например, файлы устройств)

Чтобы отменить символьные ссылки (упаковать только содержимое символьной ссылки, а не саму ссылку), задайте для `options.dereference` значение `true`.

## <a name="copy-a-directory"></a>Копирование каталога

Копирование каталога без изменения разрешений и mtime выполняется так же просто, как

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>Взаимодействие с [`tar-stream`](https://github.com/mafintosh/tar-stream)

Используйте обработчик `finalize: false` и `finish`, чтобы оставить поток упаковки открытым для дальнейших записей (см [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)) и использовать `pack` для передачи существующего потока упаковки.

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>Производительность

Упаковка и извлечение 6.1 ГБ данных с 2496 каталогами и 2398 файлами дает следующие результаты на моем Macbook Air.
[Ознакомьтесь с эталонными показателями здесь](https://gist.github.com/mafintosh/8102201)

* tar-fs: 34 261 секунд
* [node-tar](https://github.com/isaacs/node-tar): 366 123 секунд (то есть, в 10 раз медленнее)

## <a name="license"></a>Лицензия

MIT
