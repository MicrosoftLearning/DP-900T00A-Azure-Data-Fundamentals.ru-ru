---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052215"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — это реализация BigInt для JavaScript [![Статус сборки](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![jsbi в npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI — это реализация JavaScript [предложения ECMAScript BigInt](https://tc39.es/proposal-bigint/), которое официально вошло в состав языка JavaScript в ES2020.

## <a name="installation"></a>Установка

```sh
npm install jsbi --save
```

## <a name="usage"></a>Использование

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Примечание. Чтобы получить числовое представление экземпляров `JSBI`, при выполнении операции `console.log()` вызовите для них явным образом метод `toString` (например, `String(max)` или`max.toString()`). Без такой операции (например, `console.log(max)`) вы увидите объект, представляющий значение.

Для компиляции кода JSBI в собственный код BigInt используйте [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint).

Дополнительные сведения см. в приведенных ниже подробных инструкциях.

## <a name="why"></a>Почему?

[Собственные типы BigInt уже внедряются](https://v8.dev/features/bigint) в современных браузерах (на момент написания этой статьи — Google Chrome 67+, Opera 54+, Firefox 68+ и Node.js (v10.4+)), а вскоре появятся и в других браузерах, поэтому пока их нельзя использовать, если нужно, чтобы код выполнялся везде.

Чтобы использовать типы BigInt в коде сегодня, потребуется библиотека. Но здесь есть одна трудность: согласно предложению о внедрении BigInt для этого типа меняется поведение операторов (например `+`, `>=` и т. д.). Эти изменения невозможно реализовать полизаполнением напрямую, кроме того, они делают нецелесообразным (в большинстве случаев) компиляцию кода BigInt в резервный код с помощью Babel или аналогичных инструментов. Причина заключается в том, что при такой компиляции придется заменить каждый оператор в программе вызовом некоторой функции, которая проверяет типы входных данных, что приведет к неприемлемому падению производительности.

Правильным решением будет сделать все наоборот: написать код с помощью синтаксиса библиотеки и [скомпилировать его в собственный код BigInt](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) при наличии. Пакет JSBI предназначен именно для этого: он предоставляет реализацию BigInt "с полизаполнением", которая ведет себя так же, как будущие собственные типы BigInt, но в ней используется синтаксис, который сегодня поддерживается во всех браузерах.

По сравнению с другими существующими библиотеками больших целых чисел он имеет следующие преимущества:

- Он ведет себя так же, как будут себя вести собственные типы BigInt, когда они станут доступны, поэтому для перехода на них можно [механически](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) обновить синтаксис кода без реструктуризации логики.
- Повышенное внимание к производительности. В среднем JSBI по производительности не уступает собственной реализации, которую сегодня предлагает Google Chrome.

## <a name="how"></a>Как это сделать?

За исключением формальных различий в синтаксисе, тип JSBI-BigInt используется так же, [как и собственные типы BigInt](https://developers.google.com/web/updates/2018/05/bigint). Некоторые вещи даже выглядят одинаково, после замены `BigInt` на `JSBI.BigInt`:

| Операция            | Собственный BigInt          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Создание из строки | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Создание из числа | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Преобразование в строку | `a.toString(radix)`     | `a.toString(radix)`      |
| Преобразование в число | `Number(a)`             | `JSBI.toNumber(a)`       |
| Усечение           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Проверка типа           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

Большинство операторов заменяются вызовами методов:

| Операция                   | Собственный BigInt | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Сложение                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Вычитание                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Умножение              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| Деление                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Остаток                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Возведение в степень              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Отрицание                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Поразрядное отрицание            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Сдвиг влево               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Сдвиг вправо              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| Побитовое И               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| Побитовое ИЛИ                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| Побитовое исключающее ИЛИ               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Сравнение с другими значениями BigInt | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

Приведенные выше функции работают только со значениями BigInt. (Они не проверяют типы в текущей реализации, поскольку такие проверки лишь ведут к пустой трате времени, так как предполагается, что вы знаете, что делаете. Не пытайтесь вызывать эти функции с другими входными данными, так как в этом случае возникнут опасные сбои.)

Некоторые операции ведут себя особенно интересно, когда им на вход передаются данные разных типов, например при сравнении BigInt с Number или при объединении строки с BigInt. Эти операции реализуются как статические функции, названные в соответствии с собственными операторами:

| Операция                       | Собственный BigInt | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Абстрактное сравнение на равенство    | `x == y`       | `JSBI.EQ(x, y)`  |
| Универсальное "не равно"             | `x != y`       | `JSBI.NE(x, y)`  |
| Универсальное "меньше"             | `x < y`        | `JSBI.LT(x, y)`  |
| Универсальное "меньше или равно"    | `x <= y`       | `JSBI.LE(x, y)`  |
| Универсальное "больше"          | `x > y`        | `JSBI.GT(x, y)`  |
| Универсальное "больше или равно" | `x >= y`       | `JSBI.GE(x, y)`  |
| Универсальное добавление                | `x + y`        | `JSBI.ADD(x, y)` |

Имена переменных `x` и `y` здесь указывают, что переменные могут ссылаться на что угодно, например: `JSBI.GT(101.5, BigInt('100'))` или `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

К сожалению, некоторые вещи не поддерживаются вообще:

| Неподдерживаемая операция | Собственный BigInt | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| литералы              | `a = 123n;`    | Н/Д ☹                                |
| increment             | `a++`          | Н/Д ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| уменьшение             | `a--`          | Н/Д ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

Невозможно повторить точное поведение собственных операторов `++` и `--` с помощью статических функций. Так как JSBI предусматривает компиляцию в код на другом языке, он не дает похожую, но немного другую альтернативу. Вместо этих операторов можно использовать `JSBI.add()` и `JSBI.subtract()`.

## <a name="when"></a>Когда?

Теперь. Библиотеку JSBI можно использовать уже сегодня.

Когда типы BigInt получат встроенную поддержку везде, воспользуйтесь средством [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint), чтобы скомпилировать код JSBI в собственный код BigInt раз и навсегда.

Узнать больше о наших будущих планах по JSBI и присоединиться к обсуждению можно в [нашем средстве отслеживания проблем](https://github.com/GoogleChromeLabs/jsbi/issues).

Более неопределенный план на будущее — использовать библиотеку JSBI (или расширение для нее) в качестве промежуточной платформы для дополнительных функций, связанных с BigInt. Официальное предложение намеренно сделано довольно лаконичным и оставляет возможность для дальнейших предложений по "функциям библиотеки". Например, это может быть объединенная функция `exp`+`mod` и функции побитовой обработки.

## <a name="development"></a>Разработка

1. Клонируйте этот репозиторий и выполните команду `cd` для перехода в локальный каталог.

1. Используйте версию Node.js, указанную в `.nvmrc`:

     ```sh
     nvm use
     ```

1. Установите зависимости разработки:

    ```sh
    npm install
    ```

1. Запустите тесты.

    ```sh
    npm test
    ```

    Полный список команд см. в разделе `npm run`.

## <a name="for-maintainers"></a>Для поддержки

### <a name="how-to-publish-a-new-release"></a>Публикация нового выпуска

1. В ветви `main` укажите номер версии в `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Вместо `patch` используйте `minor` или `major`[при необходимости](https://semver.org/).

    Обратите внимание, что при этом выполняется фиксация и создается тег Git.

1. Выгрузите зафиксированный выпуск и тег выпуска:

    ```sh
    git push
    ```

    После этого CI автоматически опубликует новый выпуск в npm.
