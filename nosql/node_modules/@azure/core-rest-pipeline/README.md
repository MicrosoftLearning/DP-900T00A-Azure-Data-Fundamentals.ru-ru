---
ms.openlocfilehash: 6f2950dcb9eebd8a8a946f99370300d10624b1c2
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053121"
---
# <a name="azure-core-http-client-library-for-javascript-experimental"></a>Клиентская библиотека Azure Core HTTP для JavaScript (экспериментальная версия)

Это основной конвейер HTTP для библиотек JavaScript Azure SDK, которые работают в браузере и Node.js. Эта библиотека в первую очередь предназначена для использования в коде, созданном [AutoRest](https://github.com/Azure/Autorest) и [`autorest.typescript`](https://github.com/Azure/autorest.typescript).

## <a name="getting-started"></a>Начало работы

### <a name="requirements"></a>Требования

### <a name="currently-supported-environments"></a>Поддерживаемые в настоящее время среды

- [LTS версии Node.js](https://nodejs.org/about/releases/)
- Последние версии Safari, Chrome, Edge и Firefox.

Чтобы получить дополнительные сведения, ознакомьтесь с нашей [политикой поддержки](https://github.com/Azure/azure-sdk-for-js/blob/main/SUPPORT.md).

### <a name="installation"></a>Установка

Этот пакет в основном используется в созданном коде и не предназначен для непосредственного использования конечными пользователями.

## <a name="key-concepts"></a>Основные понятия

### <a name="pipelinerequest"></a>PipelineRequest

В `PipelineRequest` описаны все сведения, необходимые для выполнения запроса к конечной точке REST HTTP.

### <a name="pipelineresponse"></a>PipelineResponse

В `PipelineResponse` описан HTTP-ответ (текст, заголовки и код состояния) из конечной точки REST, возвращенной после выполнения HTTP-запроса.

### <a name="sendrequest"></a>SendRequest

Метод `SendRequest` — это метод, который с учетом `PipelineRequest` может асинхронно возвращать `PipelineResponse`.

```ts
export type SendRequest = (request: PipelineRequest) => Promise<PipelineResponse>;
```

### <a name="httpclient"></a>HttpClient

`HttpClient` — любой объект, который удовлетворяет следующему интерфейсу для реализации метода `SendRequest`:

```ts
export interface HttpClient {
  /**
   * The method that makes the request and returns a response.
   */
  sendRequest: SendRequest;
}
```

Ожидается, что `HttpClient` фактически выполнит HTTP-запрос к конечной точке сервера, используя для этого некоторый механизм, зависящий от платформы.

### <a name="pipeline-policies"></a>Политики конвейера

`PipelinePolicy` — это простой объект, реализующий следующий интерфейс:

```ts
export interface PipelinePolicy {
  /**
   * The policy name. Must be a unique string in the pipeline.
   */
  name: string;
  /**
   * The main method to implement that manipulates a request/response.
   * @param request The request being performed.
   * @param next The next policy in the pipeline. Must be called to continue the pipeline.
   */
  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
}
```

Он похож по форме на `HttpClient`, но включает имя политики, а также слегка измененную сигнатуру `SendRequest`, которая позволяет условно вызывать следующую политику в конвейере.

Роль политик можно рассматривать как `middleware`, концепцию, знакомую разработчикам NodeJS, которые работали с такими платформами, как [Express](https://expressjs.com/).

Реализация `sendRequest` может преобразовывать как исходящий запрос, так и входящий ответ:

```ts
const customPolicy = {
  name: "My wonderful policy",
  async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
    // Change the outgoing request by adding a new header
    request.headers.set("X-Cool-Header", 42);
    const result = await next(request);
    if (response.status === 403) {
      // Do something special if this policy sees Forbidden
    }
    return result;
  }
};
```

Большинство политик работают только с запросом или ответом, однако есть некоторые исключения, такие как [LogPolicy](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-rest-pipeline/src/policies/logPolicy.ts), которые регистрируют сведения от обоих.

### <a name="pipelines"></a>Pipelines

`Pipeline` — это объект, который управляет набором объектов `PipelinePolicy`. Его основная функция заключается в том, чтобы политики выполнялись в согласованном и предсказуемом порядке.

Применение политик можно рассматривать как стек (обслуживание в обратном порядке). Первая `PipelinePolicy` способна изменить `PipelineRequest` до любых других политик, и она также последней изменяет `PipelineResponse`, что делает ее ближайшей к вызывающему. Последняя политика последней может изменить исходящий запрос и первой обработать ответа, что делает ее ближайшей к сети.

`Pipeline` удовлетворяет следующему интерфейсу:

```ts
export interface Pipeline {
  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;
  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];
  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;
  getOrderedPolicies(): PipelinePolicy[];
  clone(): Pipeline;
}
```

Как видно, он позволяет добавлять или удалять политики и слабо связан с `HttpClient` для выполнения реального запроса к конечной точке сервера.

Одна из важных концепций для `Pipeline` заключается в том, что он группирует политики по упорядоченным этапам:

1. этап сериализации,
2. политики, не относящиеся к этапу,
3. этап десериализации,
4. этап повтора.

Этапы выполняются в указанном выше порядке, при этом политики сериализации применяются в первую очередь, политики повтора — в последнюю. Большинство пользовательских политик попадают во вторую группу и не получают имя этапа.

При добавлении политики в конвейер можно указать не только этап политики, но и наличие у нее зависимостей:

```ts
export interface AddPolicyOptions {
  beforePolicies?: string[];
  afterPolicies?: string[];
  afterPhase?: PipelinePhase;
  phase?: PipelinePhase;
}
```

`beforePolicies` — это политики, которые новая политика должна выполнить до, а `afterPolicies` — политики, после которых должна произойти новая политика. Аналогичным образом `afterPhase` означает, что политика должна выполняться только после выполнения указанного этапа.

Этот синтаксис позволяет авторам пользовательских политик выражать любые необходимые связи между собственными политиками и встроенными политиками, предоставляемыми `@azure/core-rest-pipeline` при создании конвейера с помощью `createPipelineFromOptions`.

Реализующие объекты также могут удалять политики по имени или этапу, если требуется изменить существующий `Pipeline`, не создавая новый, с помощью `createEmptyPipeline`. Этот метод `clone` особенно полезен при повторном создании `Pipeline` без изменения исходного.

После удовлетворения всех остальных ограничений политики применяются в том порядке, в котором они были добавлены.

## <a name="examples"></a>Примеры

Примеры можно найти в папке `samples`.

## <a name="next-steps"></a>Дальнейшие действия

Вы можете создавать и запускать тесты локально с помощью команды `rushx test`. Изучите папку `test`, чтобы увидеть расширенное использование и поведение открытых классов.

## <a name="troubleshooting"></a>Устранение неполадок

Если при использовании этой библиотеки возникают проблемы, вы можете [сообщить о проблеме](https://github.com/Azure/azure-sdk-for-js/issues/new).

## <a name="contributing"></a>Участие

Если вы хотите вносить изменения в эту библиотеку, ознакомьтесь с [руководством по внесению изменений](https://github.com/Azure/azure-sdk-for-js/blob/main/CONTRIBUTING.md), в котором содержатся сведения о создании и тестировании кода.

![Просмотры](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-js%2Fsdk%2Fcore%2Fcore-rest-pipeline%2FREADME.png)
