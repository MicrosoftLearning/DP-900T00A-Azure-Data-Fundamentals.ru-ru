---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052756"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Эмблема версии][2]][1]</sup>

[![Статус сборки][3]][4]
[![состояние зависимости][5]][6]
[![состояние зависимости разработки][7]][8]
[![Лицензия][license-image]][license-url]
[![Загрузки][downloads-image]][downloads-url]

[![эмблема npm][11]][1]

Библиотека анализа строки запроса и преобразования в строку с дополнительными средствами обеспечения безопасности.

Главный ответственный [Джордан Харбанд](https://github.com/ljharb)

Модуль **qs** изначально был создан и поддерживается [ТиДжеем Головайчуком](https://github.com/visionmedia/node-querystring).

## <a name="usage"></a>Использование

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>Анализ объектов

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** позволяет создавать вложенные объекты в строках запроса путем заключения имен вложенных ключей в квадратные скобки `[]`.
Например, строка `'foo[bar]=baz'` преобразуется в:

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

При использовании параметра `plainObjects` проанализированное значение возвращается в виде объекта NULL, созданного с помощью `Object.create(null)`. Таким образом, следует помнить, что методы прототипа не будут в нем существовать и пользователь может задать для этих имен любые значения:

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

По умолчанию параметры, которые будут перезаписывать свойства прототипа объекта, игнорируются. Если требуется сохранить данные из этих полей, либо используйте `plainObjects`, как упоминалось выше, либо задайте для `allowPrototypes` значение `true`, которое позволит пользователю вводить данные для перезаписи этих свойств. *ПРЕДУПРЕЖДЕНИЕ*. Как правило, включать этот параметр не рекомендуется, так как это может вызвать проблемы при попытке использовать перезаписанные свойства. Всегда будьте внимательные при использовании этого параметра.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

Строки в кодировке URI также работают:

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

Можно также вкладывать объекты, например `'foo[bar][baz]=foobarbaz'`:

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

По умолчанию при вложении объектов **qs** выполнит анализ на глубину не более 5 дочерних элементов. Это означает, что при попытке проанализировать, например, строку `'a[b][c][d][e][f][g][h][i]=j'` результирующий объект будет выглядеть следующим образом:

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

Эту глубину можно переопределить, передав параметр `depth` в `qs.parse(string, [options])`:

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

Ограничение глубины помогает сократить масштабы злоупотребления, когда **qs** используется для анализа введенных пользователем данных. Рекомендуется задавать в качестве его значения достаточно небольшое число.

По аналогичным причинам по умолчанию **qs** будет анализировать не более 1000 параметров. Эту значение можно переопределить, передав параметр `parameterLimit`:

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

Чтобы обойти вопросительный знак, с которого начинается строка, используйте `ignoreQueryPrefix`:

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

Можно также передать необязательный разделитель:

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

Разделители также могут быть заданы регулярным выражением:

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

Параметр `allowDots` можно использовать для включения точечной нотации:

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

Если приходится работать с устаревшими браузерами или службами, имеется также поддержка декодирования октетов с процентной кодировкой в формате iso-8859-1:

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

Некоторые службы добавляют в формы начальное значение `utf8=✓`, чтобы старые версии Internet Explorer с большей вероятностью отправили форму в формате utf-8. Кроме того, сервер может проверить значение на соответствие неправильным кодировкам символа флажка и обнаружить, что строка запроса или тело `application/x-www-form-urlencoded` были отправлены *не* в формате utf-8, например, если в форме был параметр `accept-charset` или на содержащей странице имелся другой набор символов.

**qs** поддерживает этот механизм с помощью параметра `charsetSentinel`.
Если параметр `utf8` указан, он будет опущен в возвращаемом объекте. Он будет использоваться для переключения в режим `iso-8859-1`/`utf-8` в зависимости от того, как закодирован флажок.

**Важно!** При указании как параметра `charset`, так и параметра `charsetSentinel` `charset` переопределяется, если запрос содержит параметр `utf8`, из которого можно вывести фактический набор символов. В этом смысле `charset` будет вести себя как набор символов по умолчанию, а не полномочный набор символов.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

Если требуется декодировать синтаксис `&#...;` до фактического символа, можно также указать параметр `interpretNumericEntities`:

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

Это также работает при обнаружении набора символов в режиме `charsetSentinel`.

### <a name="parsing-arrays"></a>Анализ массивов

**qs** также может анализировать массивы с помощью аналогичной нотации `[]`:

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

Можно также указать индекс:

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

Обратите внимание, что единственное различие между индексом в массиве и ключом в объекте заключается в том, что значение в квадратных скобках должно представлять собой число для создания массива. При создании массивов с определенными индексами **qs** сжимает разреженный массив только до существующих значений, сохраняя их порядок:

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

Можно также использовать параметр `allowSparse` для синтаксического анализа разреженных массивов:

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

Обратите внимание, что пустая строка также является значением и будет сохранена:

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** также будет ограничивать указание индексов в массиве максимальным индексом `20`. Все элементы массива с индексом больше `20` будут преобразованы в объект с индексом в качестве ключа. Это необходимо для обработки случаев, когда кто-то отправил, например, `a[999999999]` и на итерацию по этому огромному массиву потребуется значительное время.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

Это ограничение можно переопределить путем передачи параметра `arrayLimit`:

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

Чтобы полностью отключить анализ массива, задайте для `parseArrays` значение `false`.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

При объединении нотаций **qs** объединяет два элемента в объект:

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

Кроме того, можно создавать массивы объектов.

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

Некоторые пользователи используют запятую для объединения массива. **qs** может ее проанализировать:
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_невозможно преобразовывать вложенные объекты, например, `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>Преобразование в строку

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

При преобразовании в строку **qs** по умолчанию зашифровывает выходные данные в кодировке URI. Объекты преобразовываются в строки в соответствии с ожиданиями:

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

Это кодирование можно отключить, установив для параметра `encode` значение`false`:

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

Кодирование можно отключить для ключей, установив для параметра `encodeValuesOnly` значение`true`:
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

Это кодирование также можно заменить пользовательским набором методов кодирования в качестве параметра `encoder`:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(Примечание. Параметр `encoder` не применяется, если `encode` имеет значение `false`)_

Аналогично `encoder` имеется параметр `decoder` для `parse` для переопределения декодирования свойств и значений:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

Ключи и значения можно кодировать с помощью другой логики, используя аргумент типа, предоставленный кодировщику:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

Аргумент типа также предоставляется декодеру:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

Для ясности другие примеры будут показаны так, как если бы выходные данные не зашифровывались в кодировке URI. Обратите внимание, что возвращаемые значения в этих случаях *будут* находиться в кодировке URI при реальном использовании.

Если массивы преобразованы в строку, они по умолчанию получают явные индексы:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

Это можно переопределить, задав для параметра `indices` значение `false`:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

Можно использовать параметр `arrayFormat` для указания формата выходного массива:

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

Если объекты преобразованы в строку, они по умолчанию используют нотацию с квадратными скобками:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

Это можно переопределить, чтобы использовать точечную нотацию, задав для параметра `allowDots` значение `true`:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

Пустые строки и значения NULL опустят значение, однако знак равенства (=) остается на месте:

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

Ключ без значений (например, пустой объект или массив) ничего не вернет:

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

Свойства, для которых задано значение `undefined`, будут опущены полностью:

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

В начало строки запроса может быть дополнительно добавлен знак вопроса:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

Разделитель также может быть переопределен с помощью преобразования в строку:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

Если требуется переопределить только сериализацию объектов `Date`, можно предоставить параметр `serializeDate`:

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

Можно использовать параметр `sort`, чтобы повлиять на порядок ключей параметров:

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

Наконец, можно использовать параметр `filter`, чтобы ограничить ключи, которые будут включены в преобразованные в строку выходные данные.
Если передать функцию, она будет вызываться для каждого ключа, чтобы получить новое значение. В противном случае, если передать массив, он будет использоваться для выбора свойств и индексов массива для преобразования в строку:

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>Обработка значений `null`

По умолчанию значения `null` обрабатываются как пустые строки:

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

Анализ не различает параметры со знаками равенства и без таковых. Оба преобразуются в пустые строки.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

Чтобы различать значения `null` и пустые строки, используйте флаг `strictNullHandling`. В строке результата значения `null` не имеют знака `=`:

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

Чтобы проанализировать значения без `=` обратно до `null`, используйте флаг `strictNullHandling`:

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

Чтобы полностью пропустить отрисовку ключей со значениями `null`, используйте флаг `skipNulls`:

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

При взаимодействии с устаревшими системами можно переключиться на `iso-8859-1` с помощью параметра `charset`:

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

Символы, которые не существуют в `iso-8859-1`, будут преобразованы в числовые сущности, аналогично тому, что делают браузеры:

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

Вы можете использовать параметр `charsetSentinel` для объявления символа, включив параметр `utf8=✓` с правильным кодированием флажка аналогично тому, что делает Ruby on Rails и другие при отправке форм.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>Работа со специальными кодировками

По умолчанию кодирование и декодирование символов выполняется в `utf-8`, а поддержка `iso-8859-1` также встроена с помощью параметра `charset`.

Если требуется кодировать строки запросов в другой кодировке (т. е. [SHIFT JIS](https://en.wikipedia.org/wiki/Shift_JIS)), можно использовать библиотеку [`qs-iconv`](https://github.com/martinheidegger/qs-iconv):

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

Это также работает для декодирования строк запросов:

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>Кодирование пространства RFC 3986 и RFC 1738

RFC3986 используется в качестве параметра по умолчанию и кодирует ' ' в символ *%20*, который является обратно совместимым.
В то же время выходные данные могут быть преобразованы в строку в соответствии с RFC1738, где " " равно "+".

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>Безопасность

Отправьте сообщение по электронной почте [@ljharb](https://github.com/ljharb) или см. сведения в https://tidelift.com/security, если существует потенциальная уязвимость безопасности для отчета.

## <a name="qs-for-enterprise"></a>qs для предприятий

Доступно в рамках подписки Tidelift

Авторы qs и тысяч других пакетов работают с Tidelift в целях обеспечения коммерческой поддержки и обслуживания для зависимостей с открытым кодом, которые вы используете для создания приложений. Экономьте время, сокращайте риски и повышайте работоспособность кода, платя при этом авторам именно тех зависимостей, которые вы используете. [Подробнее.](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
