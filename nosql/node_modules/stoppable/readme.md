---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052540"
---
# <a name="stoppable"></a>Stoppable

[![Статус сборки](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> Метод `server.close()` из node.js, который, наверное, [должен был работать так с самого начала](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Сводка

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable перестает принимать новые подключения и закрывает существующие бездействующие подключения (включая проверяемые на активность), не завершая открытые запросы.

## <a name="requirements"></a>Требования

- Node.js v6+

Node.js v4.x поддерживается *неофициально*.

## <a name="installation"></a>Установка

```bash
yarn add stoppable
```

(или используйте npm)

## <a name="usage"></a>Использование

**конструктор**

```js
stoppable(server, grace)
```

Декорирует экземпляр сервера методом `stop`.
Конструктор возвращает экземпляр сервера, поэтому его можно включать в цепочки операций или запускать в виде автономной инструкции.

- server: любой экземпляр сервера HTTP или HTTPS
- grace: время в миллисекундах, по истечении которого подключения принудительно закрываются

По умолчанию `grace` имеет значение Infinity (без принудительного закрытия).
Если требуется немедленно завершить все сокеты, задайте для grace значение 0.

**stop()**

```js
server.stop(callback)
```

Закрывает сервер.

- callback: передается в существующую функцию `server.close` для автоматической регистрации события close.
Первым аргументом является ошибка, вторым — логическое значение, указывающее, было ли подключение закрыто корректно.

## <a name="design-decisions"></a>Проектные решения

- Партизанская подмена значений обычно не приветствуется, но в этом случае это оптимальное решение. Назовем его "декорированием".
- `grace` можно задать для `stop`, но лучше сделать это в соответствии с существующим API `server.close`.
- С клиентами нужно обращаться аккуратно, поэтому мы не просто уничтожаем сокеты, но сначала отправляем пакеты `FIN`.
- Для любого решения этой проблемы требуется учет всех подключений, запросов и ответов.
Мы делаем минимум работы по этим активным путям выполнения кода и обеспечиваем максимальную задержку для фактического метода `stop`.

## <a name="performance"></a>Производительность

Предоставить эту возможность без учета подключений, отключений, запросов и ответов невозможно.
Однако Stoppable стремится делать минимум работы в активных путях выполнения кода и использовать оптимальные структуры данных.

Мне было бы интересно посмотреть реальные тесты производительности; Простой тест loopback artillery, включенный в библиотеку, показывает, что использование сервера Stoppable приводит к очень небольшим издержкам:

### <a name="without-stoppable"></a>Без Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Со Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Лицензия

MIT