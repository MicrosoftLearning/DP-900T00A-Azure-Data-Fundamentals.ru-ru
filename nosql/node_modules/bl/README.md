---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052340"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Статус сборки](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Средство сбора, чтения и потоковой передачи списков буферов Node.js.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** — это объект хранилища для коллекций буферов node.js, которые предоставляются через основной API Buffer, доступный для чтения. Он ведет себя как дуплексный поток, таким образом, в зависимости от ситуации из него можно брать буферы либо их можно в него передавать.

Исходные буферы не затрагиваются, а копии создаются только при необходимости. Все операции чтения, для которых нужен один исходный буфер, возвращают только срез этого буфера (который ссылается на ту же память, что и исходный буфер). Операции чтения, охватывающие несколько буферов, выполняют объединение по мере необходимости и возвращают результаты прозрачным образом.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Укажите обратный вызов в конструкторе и используйте так же, как **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Обратите внимание, что при использовании такого метода *обратного вызова* результирующий параметр `data` является объединением всех объектов `Buffer` в списке. Если вы хотите избежать дополнительных издержек на объединение (в случае исключительно строгих требований к производительности), не используйте метод *обратного вызова*, а просто прослушивайте `'end'`, как стандартный поток.

Также можно получить URL-адрес с помощью [hyperquest](https://github.com/substack/hyperquest) (должен работать с [request](http://github.com/mikeal/request) и даже обычным HTTP-клиентом в node.js):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

Также можно использовать его в качестве потока с возможностью чтения для повторной компиляции списка буферов в выходной источник:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
Для конструктора не _требуются_ аргументы, но список можно инициализировать, передав один объект `Buffer` или массив объектов `Buffer`.

Указывать оператор `new` не обязательно. Если вы не создаете экземпляр нового объекта, он будет создан автоматически, поэтому можно просто указать:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Определяет, является ли переданный объект `BufferList`. Возвращает значение `true`, если переданный объект является экземпляром `BufferList` **, или** `BufferListStream` и `false` в противном случае.

Примечание. this не возвращает значение `true` для экземпляров `BufferList` или `BufferListStream`, созданных с помощью версий библиотеки, в которых еще не был добавлен этот статический метод.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Длина списка в байтах. Это сумма длин всех буферов, содержащихся в списке, минус любое начальное смещение для частично использованного буфера в начале. Это значение должно точно представлять общее количество байтов, которые можно считывать из списка.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` добавляет дополнительный буфер или BufferList во внутренний список. Возвращается значение `this`, что позволяет создавать цепочки.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` возвращает байт по указанному индексу.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` возвращает байт по указанному индексу.
Метод `indexOf()` возвращает первый индекс, по которому данный элемент можно найти в BufferList, или –1, если элемент отсутствует.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` возвращает новый объект `Buffer`, содержащий байты в указанном диапазоне. Оба параметра, `start` и `end`, являются необязательными и по умолчанию соответствуют началу и концу списка, соответственно.

Если запрошенный диапазон охватывает один внутренний буфер, возвращается срез этого буфера, который использует исходный диапазон памяти этого буфера. Если диапазон охватывает несколько буферов, вероятно, будут выполняться операции копирования для предоставления единого буфера.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` возвращает новый объект `BufferList`, содержащий байты в указанном диапазоне. Оба параметра, `start` и `end`, являются необязательными и по умолчанию соответствуют началу и концу списка, соответственно.

Копии не создаются. В результате все буферы используют общую с исходным списком память.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()`, начиная с положения `destStart`, копирует содержимое списка в буфере `dest`, которое содержит байты в диапазоне, заданном параметрами `srcStart` и `srcEnd`. Параметры `destStart`, `start` и `end` являются необязательными и по умолчанию соответствуют началу буфера `dest`, началу и концу списка, соответственно.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` выполняют операцию **shallow-copy** для списка. Внутренние буферы остаются неизменными, поэтому изменение базовых буферов отражается как в оригинале, так и в дубликате. Этот метод необходим, если нужно вызвать `consume()` или `pipe()` и сохранить исходный список. Пример:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` сдвигает байты *от начала списка*. Количество используемых байтов необязательно должно соответствовать размерам внутренних буферов &mdash; исходные смещения рассчитываются соответствующим образом, чтобы обеспечить согласованное представление данных.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` возвращает строковое представление буфера. Необязательные аргументы `start` и `end` передаются в `slice()`, а `encoding` передается в `toString()` результирующего буфера. Дополнительные сведения см. в разделе [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end).

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Реализованы все стандартные методы чтения байтов в интерфейсе `Buffer` и будут прозрачно работать без учета внутренних границ буфера.

Подробнее об этом см. в разделе <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b>.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream**— это **[дуплексный поток](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)в node.js** узла, поэтому данные можно считывать из него или записывать в него, как и при работе со стандартным потоком node.js. Также можно выполнять операцию `pipe()` для экземпляра **BufferListStream**.

Конструктор принимает необязательный обратный вызов, если он указан. Обратный вызов вызывается с аргументом ошибки, за которым следует ссылка на экземпляр **bl** при вызове `bl.end()` (т. е. из конвейерного потока). Это удобный метод сбора всего содержимого потока, особенно при *фрагментации* потока, например сетевого потока.

Обычно для конструктора не требуются аргументы, но список можно инициализировать, передав один объект `Buffer` или массив объектов `Buffer`.

Указывать оператор `new` не обязательно. Если вы не создаете экземпляр нового объекта, он будет создан автоматически, поэтому можно просто указать:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

Примечание. Для обеспечения обратной совместимости `BufferListStream` является форматом экспорта **по умолчанию**, когда используется `require('bl')`:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Соавторы

**bl** представлен следующими разработчиками:

 * [Род Вагг](https://github.com/rvagg)
 * [Маттео Коллина](https://github.com/mcollina)
 * [Джаретт Крюгер](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Лицензии &amp; авторские права

(c) 2013–2019 авторы bl (см. список выше).

bl лицензируется по лицензии MIT. Все права, не предоставленные явно в лицензии MIT, сохранены. Дополнительные сведения см. в прилагаемом файле LICENSE.md.
