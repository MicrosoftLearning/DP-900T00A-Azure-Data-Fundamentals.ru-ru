---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052692"
---
<a name="aproba"></a>aproba
======

Проверяющий элемент управления аргумента облегченной функции

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

Допустимые типы:

| тип | description
| :--: | :----------
| *    | соответствует любому типу
| Объект    | `Array.isArray` ИЛИ объект `arguments`
| S    | typeof == string
| Нет    | typeof == number
| C    | typeof == function
| O    | typeof == object and not type A and not type E
| B    | typeof == boolean
| E    | `instanceof Error` OR `null` **(специальный: см. ниже)**
| Z    | == `null`

Сбои проверки вызывают один из трех типов исключений, отличающихся свойством`code` в `EMISSINGARG`, `EINVALIDTYPE` или `ETOOMANYARGS`.

Если передать недопустимый тип, возникнет исключение с кодом `EUNKNOWNTYPE`.

Если обнаружен аргумент **error** (ошибка), и он не равен значению NULL, остальные аргументы являются необязательными.  То есть, если вы говорите `ESO`, то это как использование не магического `E` в: `E|ESO|ZSO`.

### <a name="but-i-have-optional-arguments"></a>Но у меня есть необязательные аргументы?!

Вы можете предоставить несколько сигнатур, разделив их каналами `|`.
Если какая-либо сигнатура соответствует аргументам, она будет считаться допустимой.

Например, предположим, что вы хотите написать сигнатуру для `fs.createWriteStream`.  В документации по ней написано:

```
fs.createWriteStream(path[, options])
```

Это будет сигнатура `SO|S`.  То есть строка и объект или просто строка.

Теперь, если прочитать все документы `fs`, можно увидеть, что фактически путь ТАКЖЕ может быть буфером.  И параметры могут быть строкой, то есть:
```
path <String> | <Buffer>
options <String> | <Object>
```

Чтобы воспроизвести это, необходимо полностью перечислить все возможные комбинации, а это означает сигнатуру `SO|SS|OO|OS|S|O`.  Неудобство – это особенность: Это напоминает вам о сложности, которую вы вносите в свой API, когда делаете подобные вещи.


### <a name="browser-support"></a>Поддержка браузеров

Это не содержит зависимостей и должно работать в браузерах, несмотря на то, что трассировки стека будут выполняться с ошибками.

### <a name="why-this-exists"></a>Почему так происходит

Мне требуется очень простой проверяющий элемент управления для аргументов. Это необходимо для выполнения двух действий:

1. Используйте более краткие и простые формы, чем проверочные утверждения

2. Не поддерживайте бесконечный DSL

Именно поэтому типы задаются одним символом, и отсутствует необязательный аргумент. 

Это не предназначено для проверки данных пользователя. Речь идет о утверждении интерфейса ваших функций.

Если требуется более существенная проверка, напишите их вручную или найдите в другом месте.

