---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052335"
---
# <a name="combined-stream"></a>combined-stream

Поток, который создает несколько других потоков по очереди.

**Примечание. Сейчас** `combined-stream` поддерживает только потоки версии 1. В настоящее время идет работа по переводу этой библиотеки на потоки версии 2. Любая помощь приветствуется. :) Вы можете изучить другие библиотеки, которые поддерживают потоки версии 2 с некоторым уровнем совместимости с `combined-stream`.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2): Прямая замена для с поддержкой потоков версии 2 для модуля combined-stream.

- [multistream](https://www.npmjs.com/package/multistream): Поток, который создает несколько других потоков по очереди.

## <a name="installation"></a>Установка

``` bash
npm install combined-stream
```

## <a name="usage"></a>Использование

Ниже приведен простой пример, в котором показано, как с помощью combined-stream объединить два файла в один:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Приведенный выше пример работает, однако он приостанавливает все исходные потоки до тех пор, пока они не понадобятся. Если вы не хотите, чтобы это произошло, задайте для параметра `pauseStreams` значение `false`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Но что делать, если у вас еще нет всех исходных потоков или вы не хотите выделять ресурсы (дескрипторы файлов, память и т. д.) для них сразу?
В этом случае можно просто указать обратный вызов, предоставляющий поток, с помощью функции `next()`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Возвращает новый объект объединенных потоков. Доступные параметры:

* `maxDataSize`
* `pauseStreams`

Эффект применения этих параметров описан ниже.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Следует ли управлять базовыми потоками. Если задано значение `false`, базовые потоки никогда не приостанавливаются. Если задано значение `true`, базовые потоки приостанавливаются сразу после добавления, а также когда метод `delayedStream.pipe()` намеревается выполнить регулирование.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

Максимальное количество байтов (или символов), которые помещаются в буфер всех исходных потоков.
Если это значение превышено, `combinedStream` создает событие `'error'`.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

Количество байтов (или символов), которые `combinedStream` поместил в буфер на текущий момент.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Добавляет указанный поток `stream` в объект combinedStream. Если `pauseStreams` имеет значение true, этот поток также сразу же приостанавливается.

`streams` также может быть функцией, которая принимает один параметр с именем `next`. `next` — это функция, которую необходимо вызвать для предоставления потока `next` (см. пример выше).

Независимо от способа добавления `stream`, combined-stream всегда присоединяет к нему прослушиватель `'error'`, поэтому этого не нужно делать вручную.

Особый случай: `stream` также может иметь тип String или Buffer.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

Вам не нужно вызывать этот метод: `combinedStream` самостоятельно включает добавленные потоки в конвейер.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Заставляет `combinedStream` запустить завершение работы потоков, которыми он управляет. Функция является идемпотентной, а также каждый раз генерирует событие `'resume'`, которое обычно передается в поток, работа которого в настоящее время завершается.

### <a name="combinedstreampause"></a>combinedStream.pause();

Если `combinedStream.pauseStreams` имеет значение `false`, метод ничего не делает.
В противном случае создается событие `'pause'`, которое передается в поток, работа которого в настоящее время завершается, поэтому его можно использовать для обратной связи.

### <a name="combinedstreamend"></a>combinedStream.end();

Задает для `combinedStream.writable` значение false, создает событие `'end'` и удаляет все потоки из очереди.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

Действует так же, как `combinedStream.end()` за исключением того, что создает событие `'close'` вместо `'end'`.

## <a name="license"></a>Лицензия

combined-stream лицензируется по лицензии MIT.
