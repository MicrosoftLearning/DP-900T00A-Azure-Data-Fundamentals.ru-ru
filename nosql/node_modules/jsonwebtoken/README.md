---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052431"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Сборка** | **Зависимость** |
|-----------|---------------|
| [![Статус сборки](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Состояние зависимостей](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Реализация [веб-маркеров JSON](https://tools.ietf.org/html/rfc7519).

Разработано на базе `draft-ietf-oauth-json-web-token-08`. Используется [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>Установка

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Примечания о переходе

* [С версии 7 на версию 8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Использование

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(асинхронно) Если предоставлен обратный вызов, он вызывается с `err` или JWT.

(синхронно) Возвращает JsonWebToken в виде строки.

`payload` может быть объектным литералом, буфером или строкой, представляющей допустимую запись JSON. 
> **_Обратите внимание,_ что**`exp` или любое другое утверждение задается, только если полезные данные представлены объектным литералом. Полезные данные в виде буфера или строки не проверяются на допустимость записи JSON.

> Если `payload` не является буфером или строкой, эти данные принудительно преобразуются в строку с помощью `JSON.stringify`.

`secretOrPrivateKey` — это строка, буфер или объект, которые содержат секрет для алгоритмов HMAC или закрытый ключ в кодировке PEM для RSA и ECDSA. Для закрытого ключа с парольной фразой можно использовать объект `{ key, passphrase }` (на основании [документации по шифрованию](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)), в этом случае обязательно передайте параметр `algorithm`.

`options`:

* `algorithm` (по умолчанию: `HS256`)
* `expiresIn`: значение в секундах или строка, которая задает интервал времени [zeit/ms](https://github.com/zeit/ms). 
  > Пример: `60`, `"2 days"`, `"10h"`, `"7d"`. Числовое значение интерпретируется как количество секунд. Если используется строка, обязательно укажите единицы времени (дни, часы и т. д.), в противном случае по умолчанию используются миллисекунды (`"120"` равно `"120ms"`).
* `notBefore`: значение в секундах или строка, которая задает интервал времени [zeit/ms](https://github.com/zeit/ms). 
  > Пример: `60`, `"2 days"`, `"10h"`, `"7d"`. Числовое значение интерпретируется как количество секунд. Если используется строка, обязательно укажите единицы времени (дни, часы и т. д.), в противном случае по умолчанию используются миллисекунды (`"120"` равно `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: если имеет значение true, функция подписи напрямую модифицирует объект полезных данных. Это удобно, когда требуется необработанная ссылка на полезные данные после применения к ним утверждений, но до кодирования в маркер.



> Для утверждений `expiresIn`, `notBefore`, `audience`, `subject` и `issuer` значений по умолчанию нет.  Эти утверждения также можно указать в полезных данных напрямую с помощью параметров `exp`, `nbf``aud``sub` и `iss`, соответственно, однако их **_нельзя_** включить в обоих местах.

Помните, что `exp`, `nbf` и `iat` имеют тип **NumericDate** (см. сведения об [истечении срока действия маркера (утверждение exp)](#token-expiration-exp-claim))


Заголовок можно настроить с помощью объекта `options.header`.

Созданные маркеры jwt по умолчанию будут включать утверждение `iat` (время выдачи), если не указано `noTimestamp`. Если утверждение `iat` включено в полезные данные, оно используется вместо метки реального времени для расчета других параметров, таких как `exp`, при заданном временном интервале `options.expiresIn`.

Синхронная подпись по умолчанию (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Синхронная подпись с RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Асинхронная подпись
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Задать время подписи jwt на 30 секунд ранее
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Срок действия маркера (утверждение exp)

В стандарте для JWT срок действия определяется с помощью утверждения `exp`. Срок действия имеет тип **numericDate**:

> Числовое значение JSON, представляющее количество секунд с момента времени 1970-01-01T00:00:00Z в формате UTC до указанной даты и времени в формате UTC без учета високосных секунд.  Это эквивалентно определению "секунд с начала эпохи" в стандарте IEEE Std 1003.1, 2013 Edition [POSIX.1], где одному дню соответствует ровно 86 400 секунд, за исключением наличия возможности представлять нецелочисленные значения.  Общие сведения о дате и времени и о формате UTC, в частности, см. в стандарте RFC 3339 [RFC3339].

Это означает, что поле `exp` должно содержать количество секунд с начала эпохи.

Подпись маркера со сроком действия 1 час:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Вот другой способ создать аналогичный маркер с помощью этой библиотеки:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(асинхронно) Если предоставляется обратный вызов, функция выполняется асинхронно. Обратный вызов вызывается с декодированными полезными данными, если действительна подпись, а также необязательные параметры срока действия, аудитории или издателя. В противном случае вызов сопровождается ошибкой.

(синхронно) Если обратный вызов не предоставляется, функция выполняется синхронно. Возвращает декодированные полезные данные, если действительна подпись, а также необязательные параметры срока действия, аудитории или издателя. В противном случае возникает ошибка.

`token` — это строка JsonWebToken.

`secretOrPublicKey` — это строка или буфер, которые содержат секрет для алгоритмов HMAC или открытый ключ в кодировке PEM для RSA и ECDSA.
Если `jwt.verify` вызывается в асинхронном режиме, `secretOrPublicKey` может быть функцией, которая должна получить секретный или открытый ключ. Подробный пример см. ниже.

Как упоминалось в [этом комментарии](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), существуют и другие библиотеки, которые ожидают секреты в кодировке Base64 (случайные байты, закодированные с помощью base64). В таком случае можно передать `Buffer.from(secret, 'base64')`. При этом секрет будет декодирован с помощью base64, а для проверки маркера будут использоваться исходные случайные байты.

`options`

* `algorithms`. Список строк с именами разрешенных алгоритмов. Например, `["HS256", "HS384"]`.
* `audience`: задайте значение, чтобы проверить аудиторию (`aud`). Аудиторию можно проверить по строке, регулярному выражению или списку строк или регулярных выражений. 
  > Пример: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: возвращает объект с декодированными значениями `{ payload, header, signature }` вместо обычного содержимого полезных данных.
* `issuer` (необязательный): строка или массив строк допустимых значений для поля `iss`.
* `ignoreExpiration`: если имеет значение `true`, срок действия маркера не проверяется.
* `ignoreNotBefore`...
* `subject`: задайте значение, чтобы проверить тему (`sub`).
* `clockTolerance`: количество секунд, на которое могут различаться значения времени при проверке утверждений `nbf` и `exp`. Позволяет учитывать небольшие различия в показаниях часов на разных серверах.
* `maxAge`: максимальное время, в течение которого маркеры остаются действительными. Выражается в секундах или в виде строки, которая задает интервал времени [zeit/ms](https://github.com/zeit/ms). 
  > Пример: `1000`, `"2 days"`, `"10h"`, `"7d"`. Числовое значение интерпретируется как количество секунд. Если используется строка, обязательно укажите единицы времени (дни, часы и т. д.), в противном случае по умолчанию используются миллисекунды (`"120"` равно `"120ms"`).
* `clockTimestamp`: время в секундах, которое должно использоваться в качестве текущего времени для всех необходимых сравнений.
* `nonce`: задайте значение, чтобы проверить утверждение `nonce`. Параметр используется в OpenID для маркеров идентификации. ([Заметки о реализации OpenID](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(синхронно) Возвращает декодированные полезные данные без проверки допустимости подписи.

> __Предупреждение.__ Проверка допустимости подписи __не__ выполняется. __Не__ следует использовать эту функцию для недоверенных сообщений. Вместо этого используйте `jwt.verify`.

`token` — это строка JsonWebToken.

`options`:

* `json`: принудительное выполнение JSON.parse для полезных данных, даже если заголовок не содержит `"typ":"JWT"`.
* `complete`: возвращает объект с декодированными полезными данными и заголовком.

Пример

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Ошибки и коды
Возможные ошибки при проверке.
Ошибка — это первый аргумент обратного вызова проверки.

### <a name="tokenexpirederror"></a>TokenExpiredError

Ошибка возникает, если срок действия маркера истек.

Объект Error:

* name: 'TokenExpiredError'
* message: 'jwt expired'
* expiredAt: [СрокДействия]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Объект Error:

* name: 'JsonWebTokenError'
* сообщение:
  * 'jwt malformed'
  * 'jwt signature is required'
  * 'invalid signature'
  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]'
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'
  * 'jwt id invalid. expected: [OPTIONS JWT ID]'
  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Возникает, если время в утверждении nbf оказывается после текущего времени.

Объект Error:

* name: 'NotBeforeError'
* message: 'jwt not active'
* date: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Поддерживаемые алгоритмы

Массив поддерживаемых алгоритмов. Сейчас поддерживаются следующие алгоритмы:

Значение параметра | Алгоритм цифровой подписи или MAC
----------------|----------------------------
HS256 | HMAC с использованием хэш-алгоритма SHA-256
HS384 | HMAC с использованием хэш-алгоритма SHA-384
HS512 | HMAC с использованием хэш-алгоритма SHA-512
RS256 | RSASSA-PKCS1-v1_5 с использованием хэш-алгоритма SHA-256
RS384 | RSASSA-PKCS1-v1_5 с использованием хэш-алгоритма SHA-384
RS512 | RSASSA-PKCS1-v1_5 с использованием хэш-алгоритма SHA-512
PS256 | RSASSA-PSS с использованием хэш-алгоритма SHA-256 (только для версии node ^6.12.0 или 8.0.0 и более поздних)
PS384 | RSASSA-PSS с использованием хэш-алгоритма SHA-384 (только для версии node ^6.12.0 или 8.0.0 и более поздних)
PS512 | RSASSA-PSS с использованием хэш-алгоритма SHA-512 (только для версии node ^6.12.0 или 8.0.0 и более поздних)
ES256 | ECDSA с использованием кривой P-256 и хэш-алгоритма SHA-256
ES384 | ECDSA с использованием кривой P-384 и хэш-алгоритма SHA-384
ES512 | ECDSA с использованием кривой P-521 и хэш-алгоритма SHA-512
нет | Отсутствуют цифровые подписи или значения MAC

## <a name="refreshing-jwts"></a>Обновление JWT

Во-первых, рекомендуется тщательно проверить, не приведет ли автоматическое обновление JWT к появлению уязвимостей в системе.

Мы не хотим включать эту возможность в библиотеку, однако вы можете ознакомиться с [этим примером](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48), в котором показано, как это сделать.
Помимо этого примера, есть [описание проблемы](https://github.com/auth0/node-jsonwebtoken/issues/122) и [запрос на отзыв](https://github.com/auth0/node-jsonwebtoken/pull/172), где можно получить дополнительные сведения по этой теме.

# <a name="todo"></a>TODO

* Цепочка сертификатов X.509 не проверяется

## <a name="issue-reporting"></a> Отчеты об ошибках 

Если вы обнаружили ошибку или у вас есть запрос на функцию, сообщите о них в этом разделе проблем с репозиторием. Не сообщайте об уязвимостях системы безопасности в общедоступном средстве отслеживания проблем на GitHub. Процедура раскрытия информации о проблемах безопасности описывается в разделе [Программа ответственного раскрытия информации](https://auth0.com/whitehat).

## <a name="author"></a>Автор

[Auth0](https://auth0.com)

## <a name="license"></a>Лицензия

Этот проект ведется по лицензии MIT. Дополнительные сведения см. в файле [LICENSE](LICENSE).
