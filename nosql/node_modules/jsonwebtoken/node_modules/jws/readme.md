---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052002"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![Статус сборки](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)

Реализация [веб-подписей JSON](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Она был разработана с учетом `draft-ietf-jose-json-web-signature-08` и реализует всю спецификацию, **за исключением** подписывания и проверки цепочки сертификатов X.509 (исправления приветствуются).

Доступны как синхронные API (`jws.sign`, `jws.verify`), так и ФЗAPI потоковой передачи (`jws.createSign`, `jws.createVerify`).

# <a name="install"></a>Установка

```bash
$ npm install jws
```

# <a name="usage"></a>Использование

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Массив поддерживаемых алгоритмов. Сейчас поддерживаются следующие алгоритмы:

Значение параметра | Алгоритм цифровой подписи или MAC
----------------|----------------------------
HS256 | HMAC с использованием хэш-алгоритм SHA-256.
HS384 | HMAC с использованием хэш-алгоритм SHA-384.
HS512 | HMAC с использованием хэш-алгоритм SHA-512.
RS256 | RSASSA с использованием хэш-алгоритма SHA-256
RS384 | RSASSA с использованием хэш-алгоритма SHA-384
RS512 | RSASSA с использованием хэш-алгоритма SHA-512
PS256 | RSASSA-PSS с использованием хэш-алгоритма SHA-256
PS384 | RSASSA-PSS с использованием хэш-алгоритма SHA-384
PS512 | RSASSA-PSS с использованием хэш-алгоритма SHA-512
ES256 | ECDSA с использованием кривой P-256 и хэш-алгоритма SHA-256
ES384 | ECDSA с использованием кривой P-384 и хэш-алгоритма SHA-384
ES512 | ECDSA с использованием кривой P-521 и хэш-алгоритма SHA-512
нет | Отсутствуют цифровые подписи или значения MAC

## <a name="jwssignoptions"></a>jws.sign(options)

(Синхронный) Возвращает веб-подпись JSON для заголовка и полезных данных.

Параметры:

* `header`
* `payload`
* `secret` или `privateKey`
* `encoding` (Необязательно, по умолчанию используется 'utf8')

`header` должен быть объектом со свойством `alg`. `header.alg` должно быть одним значением в `jws.ALGORITHMS`. См. таблицу поддерживаемых алгоритмов выше.

Если `payload` не является буфером или строкой, он будет принудительно перемещен в строку с помощью `JSON.stringify`.

Пример

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(Синхронная) Возвращает `true` или `false`, чтобы определить, соответствует ли подпись секрету или ключу.

`signature` это подпись JWS. `header.alg` должно быть одним значением в `jws.ALGORITHMS`.
См. таблицу поддерживаемых алгоритмов выше. `secretOrKey` — это строка или буфер, которые содержит секрет для алгоритмов HMAC или открытый ключ в кодировке PEM для RSA и ECDSA.

Обратите внимание, что значение `"alg"` из заголовка подписи игнорируется.


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(Синхронная) Возвращает декодированные заголовки, декодированные полезные данные и части подписи JWS.

Возвращает объект с тремя свойствами, например
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

Возвращает новый объект SignStream.

Параметры:

* `header` (обязательный)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Необязательно, по умолчанию используется 'utf8')

Кроме `header` все параметры ожидают строку или буфер, если значение известно заранее, или поток в целях удобства.
`key`/`privateKey`/`secret` также может быть объектом, если используется шифрованный закрытый ключ, см. [документацию по шифрованию][encrypted-key-docs].

Пример.

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

Возвращает новый объект VerifyStream.

Параметры:

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Необязательно, по умолчанию используется 'utf8')

Все параметры ожидают строку или буфер, если значение известно заранее, или поток в целях удобства.

Пример.

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Класс: SignStream

`Readable Stream`, который создает одно событие данных (вычисляемая подпись) по завершении.

### <a name="event-done"></a>Событие: "done"
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

Значение `Writable Stream`, ожидающее полезные данные JWS. *Не* используйте, если вы передали параметр `payload` конструктору.

Пример.

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

`Writable Stream`. Ожидает секрет JWS для HMAC или privateKey для ECDSA и RSA. *Не* используйте, если вы передали параметр `secret` или `key` конструктору.

Пример.

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Класс: VerifyStream

Это событие `Readable Stream`, которое создает одно событие данных, результат определения того, была ли эта подпись допустимой.

### <a name="event-done"></a>Событие: "done"
`function (valid, obj) { }`

`valid` — логическое значение, указывающее, является ли подпись допустимой.

### <a name="verifiersignature"></a>verifier.signature

`Writable Stream`, который ожидает подпись JWS. *Не* используйте, если вы передали параметр `signature` конструктору.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

`Writable Stream`, который ожидает открытый ключ или секрет. *Не* используйте, если вы передали параметр `key` или `secret` конструктору.

# <a name="todo"></a>TODO

* Предполагается, что должны быть доступны некоторые удобные параметры или API для определения алгоритма без необходимости каждый раз определять объект заголовка или `{ alg: 'ES512' }`.

* Поддержка X.509

# <a name="license"></a>Лицензия

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
